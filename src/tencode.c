#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#if defined(TIGHT_TRACE)
#include <ctype.h>
#endif

#include "tdebug.h"
#include "tinternal.h"
#include "tstate.h"
#include "tbuffer.h"



/* 
 * Internal frequency table 
 * Generated by scanning my personal home directory...
 * TODO(jure): clamp these values for better readability
 */
static const size_t internal_freqs[TIGHTBYTES] = {
	19545057148, 3531108214, 1608094686, 1345198511, 1051892339, 1281745510,
	1025513827, 1293687674, 1074268988, 1039079184, 1506712383, 1006938116,
	795036552, 819284256, 852720474, 968347569, 1196237159, 807296250,
	786485745, 731167573, 781870300, 763658141, 738518199, 758042149,
	829081582, 685694952, 678796172, 676470373, 702196128, 666433739,
	683222022, 736999294, 2958994857, 779549982, 970811770, 748844265,
	2791295041, 782214617, 749453427, 746809483, 901992964, 854420995,
	853510029, 752541364, 862078787, 895318580, 871196875, 996286245,
	1142965387, 951312275, 897361636, 832370440, 833594196, 877280491,
	816667022, 818486808, 852146631, 857172604, 853105995, 776436170,
	846287620, 806242722, 824778664, 891514664, 1568753874, 978313472,
	853034202, 828046685, 951234698, 904186093, 765447813, 721993000,
	952508445, 2772622197, 763032728, 707757167, 809345295, 784046744,
	779820569, 748080777, 916397991, 741497902, 895733761, 825590259,
	921582190, 1410512585, 779314963, 852379720, 829165307, 710956480,
	776220169, 721986867, 755255426, 745245184, 763461684, 1211140497,
	1227317123, 1180594804, 925826420, 1026633696, 1017023507, 1432370508,
	918557547, 816561729, 918723200, 1164397897, 777094249, 792277091,
	1016234870, 960079981, 1126487943, 1098093242, 978665597, 721869246,
	1191747305, 1138392234, 1264131985, 955209081, 833546979, 843656902,
	904019433, 781422670, 816126058, 791862043, 720578188, 765742304,
	788591215, 1147773006, 1712655311, 817868332, 844748524, 823909767,
	812708759, 736280498, 745345572, 701548435, 802590272, 884113835,
	786187744, 858603931, 734290325, 788617276, 705835575, 717950119,
	848129761, 713005070, 2568746106, 705717055, 759590307, 752072442,
	717126578, 711291732, 729814559, 712423716, 696898312, 704859226,
	709502527, 676758481, 677280091, 689800715, 1242406300, 685941610,
	763057463, 701885520, 731867652, 743022578, 716962124, 702450609,
	822948599, 753694915, 1518687795, 827312002, 727994792, 824051557,
	763994388, 815026818, 721157140, 673981331, 688732575, 669665978,
	699130050, 853058759, 764322091, 728838860, 702351647, 685593462,
	761087802, 743002265, 687169052, 845386414, 755058012, 849555754,
	1379241633, 673989477, 680363645, 699588927, 691508678, 680381279,
	717122561, 730331068, 688976887, 719295107, 686018355, 698392536,
	715046721, 708421468, 717085182, 703626425, 745836891, 675432857,
	674991176, 674358242, 667656210, 845247119, 734289225, 776049057,
	707136643, 669937268, 691263779, 745442244, 703373116, 746489879,
	740342449, 775085830, 1481481747, 652846418, 689050812, 690898299,
	684159252, 680178686, 688683763, 734799744, 798865773, 715575417,
	805350383, 776156546, 695178132, 739140401, 792396706, 813911924,
	795949588, 702618702, 672532244, 704033862, 682235836, 840446583,
	748366370, 809374385, 967943703, 818837829, 1044098607, 1498659876,
	1565985814, 1125047180, 1200921949, 3807361529, 
};


/* write 'magic' */
static inline void encodemagic(BuffWriter *bw) {
	t_trace("---Encoding [magic]---\n");
	t_assert(bw->len == 0 && bw->validbits == 0);
	tightB_writebyte(bw, MAGIC[0]);
	tightB_writebyte(bw, MAGIC[1]);
	tightB_writebyte(bw, MAGIC[2]);
	tightB_writebyte(bw, MAGIC[3]);
	tightB_writebyte(bw, MAGIC[4]);
	tightB_writebyte(bw, MAGIC[5]);
	tightB_writebyte(bw, MAGIC[6]);
	tightB_writebyte(bw, MAGIC[7]);
	t_tracef("%.*s\n", (int)sizeof(MAGIC), MAGIC);
}


/* auxiliary to 'encodebindata', encodes Huffman tree structure */
static void encodetree(BuffWriter *bw, TreeData *ht) {
	if (ht->left) { /* parent tree ? */
		tightB_writenbits(bw, 0, 1); /* mark as parent */
		t_trace("[");
		encodetree(bw, ht->left); /* traverse left */
		t_trace(", ");
		encodetree(bw, ht->right); /* traverse right */
		t_trace("]");
	} else { /* leaf */
		t_assert(ht->right == NULL && 0 <= ht->c && ht->c < 256);
		tightB_writenbits(bw, 1, 1); /* mark as leaf */
		t_tracef((isgraph(ht->c) ? "%c" : "%hu"), ht->c);
		tightB_writenbits(bw, ht->c, 8); /* write symbol */
	}
}


static inline void encodebindata(BuffWriter *bw, int mode) {
	t_assert(bw->ts->hufftree);
	if (mode & MODEHUFF) {
		t_trace("---Encoding [tree]----\n");
		encodetree(bw, bw->ts->hufftree);
		t_trace("\n");
	}
	if (mode & MODELZW) {/* TODO(jure): implement LZW */}
	tightB_writepending(bw);
	tightB_writefile(bw);
}


/* write MD5 digest */
static inline void encodechecksum(BuffWriter *bw, int mode) {
	tight_State *ts = bw->ts;
	byte md5digest[16];

	(void)mode; /* unused for now */
	/* get size of 'bindata' */
	off_t bindatasz = lseek(bw->fd, 0, SEEK_CUR) - TIGHTbindataoffset;
	if (t_unlikely(bindatasz < 0))
		tightD_errnoerr(ts, "lseek error in output file");
	t_assert(bindatasz > 0);

	/* seek to start of the 'bindata' */
	if (t_unlikely(lseek(bw->fd, TIGHTbindataoffset, SEEK_SET) < 0))
		tightD_errnoerr(ts, "lseek error in output file");
	tightB_genMD5(ts, bindatasz, bw->fd, md5digest);
	t_assert(lseek(bw->fd, 0, SEEK_CUR) == (off_t)TIGHTbindataoffset + bindatasz);

	t_trace("---Encoding [checksum MD5]---\n");
	tightB_writebyte(bw, md5digest[0]);
	tightB_writebyte(bw, md5digest[0]);
	tightB_writebyte(bw, md5digest[1]);
	tightB_writebyte(bw, md5digest[2]);
	tightB_writebyte(bw, md5digest[3]);
	tightB_writebyte(bw, md5digest[4]);
	tightB_writebyte(bw, md5digest[5]);
	tightB_writebyte(bw, md5digest[6]);
	tightB_writebyte(bw, md5digest[7]);
	tightB_writebyte(bw, md5digest[8]);
	tightB_writebyte(bw, md5digest[8]);
	tightB_writebyte(bw, md5digest[9]);
	tightB_writebyte(bw, md5digest[10]);
	tightB_writebyte(bw, md5digest[11]);
	tightB_writebyte(bw, md5digest[12]);
	tightB_writebyte(bw, md5digest[13]);
	tightB_writebyte(bw, md5digest[14]);
	tightB_writebyte(bw, md5digest[15]);
	tightB_writefile(bw);
#if defined(TIGHT_TRACE)
	for (uint i = 0; i < sizeof(md5digest); i++) {
		t_tracef("%02X", md5digest[i]);
		if ((i + 1) % 2 == 0) t_trace(" ");
	}
	t_trace("\n");
#endif
}


/* compress/encode header */
static inline void encodeheader(BuffWriter *bw, int mode) {
	encodemagic(bw);
	encodebindata(bw, mode);
	encodechecksum(bw, mode);
}


/* compress file contents */
static void encodehuffman(BuffReader *br, BuffWriter *bw) {
	tight_State *ts = br->ts;
	int c;

	t_trace("---Encoding [huffman]---\n");
	while ((c = tightB_brgetc(br)) != TIGHTEOF) {
		t_assert(c >= 0 && c <= UCHAR_MAX);
		HuffCode *hc = &ts->codes[c];
		tightD_printbits(hc->code, hc->nbits);
		t_trace(" ");
		tightB_writenbits(bw, hc->code, hc->nbits);
	}
	t_trace("\n");
}


/* 
 * Write 'eof' for huffman codes; last 'EOFBITS'
 * of the last byte encode how many bits to read
 * from the byte before it + 'EOFBIAS'.
 * For example, in case last 'EOFBITS' are '001' (1),
 * then 7 bits will be read from the previous byte.
 */
static void encodeeof(BuffWriter *bw) {
	int extra = 0;

	if (bw->validbits >= 8) {
		tightB_writebyte(bw, bw->tmpbuf);
		bw->tmpbuf >>= 8;
		bw->validbits -= 8;
		extra = 2;
	}
	if (bw->validbits <= 5) { /* 'eof' can fit ? */
		bw->tmpbuf <<= 8 - bw->validbits; /* shift valid bits */
		bw->tmpbuf |= bw->validbits + extra; /* add 'eof' bits */
		tightB_writebyte(bw, bw->tmpbuf);
	} else { /* 'eof' must be in separate byte */
		t_assert(EOFBIAS <= bw->validbits);
		tightB_writebyte(bw, bw->tmpbuf);
		tightB_writebyte(bw, bw->validbits - EOFBIAS);
	}
	bw->validbits = 0;
	tightB_writefile(bw); /* write all */
}


/* huffman encoding */
static void encodefile(BuffWriter *bw, BuffReader *br, int mode) {
	encodeheader(bw, mode);
	if (mode & MODELZW) {/* TODO(jure): implement LZW */}
	if (mode & MODEHUFF) 
		encodehuffman(br, bw);
	encodeeof(bw);
}


/* 
 * Encode input file, write the result into output file; 
 * user of the API should ensure that the input file is a
 * regular file and not a directory, symbolic link or any
 * other special file, otherwise some system calls might
 * have undefined behaviour.
 */
TIGHT_API void tight_encode(tight_State *ts, int mode, const size_t *freqs) {
	BuffReader br; BuffWriter bw;

	/* must have valid files */
	t_assert(ts->rfd >= 0 && ts->wfd >= 0 && ts->rfd != ts->wfd);

	if (t_unlikely(!(mode & MODEALL)))
		tightD_error(ts, "invalid mode bits for encoding");

	/* init reader and writer */
	tightB_initbr(&br, ts, ts->rfd);
	tightB_initbw(&bw, ts, ts->wfd);

	/* TODO(jure): implement LZW */
	if (mode & MODEHUFF) /* using huffman coding ? */
		tightS_gencodes(ts, freqs ? freqs : internal_freqs);
	encodefile(&bw, &br, mode);
}
